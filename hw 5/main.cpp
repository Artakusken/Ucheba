void foo_if()
{
    int a = 1;
    if( a == 1 )
        a = a + 10;
    else
        a = a * 2;
}


void foo_switch()
{
    int a = 0;
    switch(a)
    {
        case 0: a = a + 10;
            break;
        case 1: a = a * 2;
            break;
    }
}


void foo_ternary()
{
    int a = 0;
    a = a == 1 ? a + 10 : a * 2;
}

int main() {
//    a$ = 0
//    void foo_if(void) PROC                           ; foo_if
//    $LN5:
    //    sub     rsp, 24                       выделение 24 байтов в стеке для процедуры
    //    mov     DWORD PTR a$[rsp], 1          в стеке присваивается переменной а значение 1
    //    cmp     DWORD PTR a$[rsp], 1          сравнение значения в стеке с 1
    //    jne     SHORT $LN2@foo_if             прыжок к $LN2@foo_if если сравнение дало ложь
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    add     eax, 10                       добавление 10 к еах
    //    mov     DWORD PTR a$[rsp], eax        в стек на место а записывается значение еах
    //    jmp     SHORT $LN3@foo_if             прыжок к концу процедуры
//    $LN2@foo_if:
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    shl     eax, 1                        еах сдвигается побитово влево на 1 == умножению на два
    //    mov     DWORD PTR a$[rsp], eax        в стек на место а записывается значение еах
//    $LN3@foo_if:
    //    add     rsp, 24                       освобждение 24 байтов в стеке
    //    ret     0                             конец (вернуть 0)
//    void foo_if(void) ENDP                           ; foo_if


//    a$ = 0
//    tv64 = 4
//    void foo_switch(void) PROC                       ; foo_switch
//    $LN7:
    //    sub     rsp, 24                       выделение 24 байтов в стеке для процедуры
    //    mov     DWORD PTR a$[rsp], 0          в стеке присваивается переменной а значение 0
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    mov     DWORD PTR tv64[rsp], eax      присваивание в стеке значения еах. tv64[rsp] - указатель на память локальной переменной свитча?
    //    cmp     DWORD PTR tv64[rsp], 0        сравнение значения локальной переменной свитча в стеке с 0
    //    je      SHORT $LN4@foo_switch         прыжок к $LN4@foo_switch если сравнение дало правду
    //    cmp     DWORD PTR tv64[rsp], 1        сравнение значения локальной переменной свитча в стеке с 1
    //    je      SHORT $LN5@foo_switch         прыжок к $LN5@foo_switch если сравнение дало правду
    //    jmp     SHORT $LN2@foo_switch         прыжок к концу процедуры
//    $LN4@foo_switch:
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    add     eax, 10                       добавление 10 к еах
    //    mov     DWORD PTR a$[rsp], eax        в стек на место а записывается значение еах
    //    jmp     SHORT $LN2@foo_switch         прыжок к концу процедуры
//    $LN5@foo_switch:
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    shl     eax, 1                        еах сдвигается побитово влево на 1 == умножению на два
    //    mov     DWORD PTR a$[rsp], eax        в стек на место а записывается значение еах
//    $LN2@foo_switch:
    //    add     rsp, 24                       освобждение 24 байтов в стеке
    //    ret     0                             конец (вернуть 0)
//    void foo_switch(void) ENDP                       ; foo_switch


//    a$ = 0
//    tv67 = 4
//    void foo_ternary(void) PROC                                ; foo_ternary
//    $LN5:
    //    sub     rsp, 24                       выделение 24 байтов в стеке для процедуры
    //    mov     DWORD PTR a$[rsp], 0          в стеке присваивается переменной а значение 0
    //    cmp     DWORD PTR a$[rsp], 1          сравнение значения в стеке с 1
    //    jne     SHORT $LN3@foo_ternar         прыжок к $LN3@foo_ternar если сравнение дало ложь
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    add     eax, 10                       добавление 10 к еах
    //    mov     DWORD PTR tv67[rsp], eax      присваивание в стеке значения еах. tv67[rsp] - указатель на память локальной переменной тернарного оператора?
    //    jmp     SHORT $LN4@foo_ternar         прыжок к концу процедуры
//    $LN3@foo_ternar:
    //    mov     eax, DWORD PTR a$[rsp]        регистр еах получает значение из стека
    //    shl     eax, 1                        еах сдвигается побитово влево на 1 == умножению на два
    //    mov     DWORD PTR tv67[rsp], eax      присваивание в стеке значения еах. tv67[rsp] - указатель на память локальной переменной тернарного оператора?
//    $LN4@foo_ternar:
    //    mov     eax, DWORD PTR tv67[rsp]      регистр еах получает значение локальной переменной тернарного из стека
    //    mov     DWORD PTR a$[rsp], eax        в стек на место а записывается значение еах
    //    add     rsp, 24                       освобждение 24 байтов в стеке
    //    ret     0                             конец (вернуть 0)
//    void foo_ternary(void) ENDP                                ; foo_ternary


//  if else - самый эффективный (только один указатель на стек (для переменной а) и работает всё только с этой переменной/указателем)
//    -----LN2-------
//    ↑             |
//    |             ↓
//  LN5 ---------→ LN3
//

//  switch - (2 указателя на стек (для переменной а и какой-то другой, я назвал её локальной переменной свитча), работает и с той и с этой переменной/указателем)
//    -----LN4----------
//    ↑                |
//    |   ---LN5-------|
//    |   ↑            ↓
//  LN7 --|---------→ LN2
//

//  ternary - (2 указателя на стек (для переменной а и какой-то другой, я назвал её локальной переменной тернарного оператора),
//  работает и с той и с этой переменной/указателем - из-за этого на две операции больше, хотя всё остальное - идентично if else)
//    -----LN3-------
//    ↑             |
//    |             ↓
//  LN5 ---------→ LN4
//

    return 0;
}